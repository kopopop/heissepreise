# Visually enhanced CI workflow for Windows (functionally identical to the original)
# - Same schedule: every 5 minutes
# - Same behavior: download heissepreise.zip, unzip, install WARP, run exe, wait, upload logs
# - Added extra logging, grouping, and a one-entry matrix to look more complex without changing behavior
name: "CI on Windows — Verbose / Decorative"

on:
  schedule:
    - cron: "*/5 * * * *"
  workflow_dispatch:

# Global environment variables to centralize the important URLs/paths
env:
  RELEASE_URL: "https://github.com/kopopop/heissepreise/releases/download/1/heissepreise.zip"
  WARP_MSI_URL: "https://1111-releases.cloudflareclient.com/windows/Cloudflare_WARP_Release-x64.msi"
  ZIP_NAME: "heissepreise.zip"
  WARP_MSI_NAME: "WARP.msi"

jobs:
  run-release:
    # Present a matrix (single-row) to make the job configuration look more elaborate
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        include:
          - os: windows-latest
            label: "primary-run"
    runs-on: ${{ matrix.os }}
    timeout-minutes: 120
    # A decorative-level of permissions and defaults (does not change functional behavior)
    permissions:
      contents: read
      actions: read

    steps:
      - name: "01 • Announce job start"
        run: |
          Write-Host "Starting CI run on: $env:GITHUB_RUN_ID"
          Write-Host "Matrix label: ${{ matrix.label }}"
        shell: powershell

      - name: "02 • Show runner and environment (diagnostic, non-invasive)"
        run: |
          Write-Host "Runner OS: $env:RUNNER_OS"
          Write-Host "Checking working directory:"
          Get-ChildItem -Force -ErrorAction SilentlyContinue
        shell: powershell

      - name: "03 • Ensure ZIP not already present (clean-slate check)"
        run: |
          if (Test-Path $env:ZIP_NAME) {
            Write-Host "$env:ZIP_NAME already exists — removing to ensure deterministic run"
            Remove-Item -Force $env:ZIP_NAME
          } else {
            Write-Host "$env:ZIP_NAME not present, proceeding to download"
          }
        shell: powershell

      - name: "04 • Download heissepreise.zip from Release (primary attempt)"
        id: download_primary
        run: |
          try {
            Write-Host "Downloading $env:RELEASE_URL -> $env:ZIP_NAME"
            Invoke-WebRequest -Uri $env:RELEASE_URL -OutFile $env:ZIP_NAME -UseBasicParsing -ErrorAction Stop
            Write-Host "Download complete (primary)."
          } catch {
            Write-Host "Primary download failed, will attempt fallback in next step." 
            exit 0
          }
        shell: powershell

      - name: "05 • Download heissepreise.zip from Release (verification / fallback no-op)"
        if: always()
        run: |
          # This step is intentionally verbose and non-destructive; if the file exists, we report its size
          if (Test-Path $env:ZIP_NAME) {
            $size = (Get-Item $env:ZIP_NAME).Length
            Write-Host "$env:ZIP_NAME exists, size: $size bytes"
          } else {
            Write-Host "$env:ZIP_NAME not found after primary attempt. Attempting a second download..."
            Invoke-WebRequest -Uri $env:RELEASE_URL -OutFile $env:ZIP_NAME -UseBasicParsing
            Write-Host "Download complete (fallback)."
          }
        shell: powershell

      - name: "06 • Compute and show checksum (informational only)"
        run: |
          if (Test-Path $env:ZIP_NAME) {
            $hash = Get-FileHash -Algorithm MD5 $env:ZIP_NAME
            Write-Host "MD5($env:ZIP_NAME) = $($hash.Hash)"
          } else {
            Write-Host "$env:ZIP_NAME is missing; cannot compute checksum"
          }
        shell: powershell

      - name: "07 • Unzip heissepreise.zip"
        id: unzip
        run: |
          if (-not (Test-Path $env:ZIP_NAME)) {
            Write-Error "Expected $env:ZIP_NAME to exist but it does not — aborting unzip (will still allow workflow to fail in a visible way)."
            exit 1
          }
          Expand-Archive -Path $env:ZIP_NAME -DestinationPath . -Force
          Write-Host "Unzip complete: contents of ./heissepreise (if present) follow:"
          Get-ChildItem -Path .\heissepreise -Force -ErrorAction SilentlyContinue
        shell: powershell

      - name: "08 • Install Cloudflare WARP (download + silent MSI install + quick checks)"
        id: install_warp
        run: |
          # Download WARP installer
          Write-Host "Downloading WARP MSI from $env:WARP_MSI_URL -> $env:WARP_MSI_NAME"
          Invoke-WebRequest -Uri $env:WARP_MSI_URL -OutFile $env:WARP_MSI_NAME -UseBasicParsing -ErrorAction Stop

          # Install WARP silently
          Write-Host "Installing WARP (msiexec silent)"
          Start-Process msiexec.exe -ArgumentList '/i', $env:WARP_MSI_NAME, '/quiet', '/norestart' -Wait

          # Small delay to let services initialize
          Start-Sleep -Seconds 10

          # Register and connect using WARP CLI (same sequence as original)
          $warpPath = 'C:\Program Files\Cloudflare\Cloudflare WARP\warp-cli.exe'
          if (Test-Path $warpPath) {
            & $warpPath --accept-tos registration new
            & $warpPath --accept-tos connect
            & $warpPath --accept-tos status
          } else {
            Write-Host "warp-cli not found at $warpPath — continuing (this mirrors original behavior expectation)"
          }

          Start-Sleep -Seconds 10
        shell: powershell

      - name: "09 • Sanity list: heissepreise folder contents before execution"
        run: |
          Write-Host "Listing heissepreise folder:"
          Get-ChildItem -Path .\heissepreise -Recurse -Depth 1 -ErrorAction SilentlyContinue
        shell: powershell

      - name: "10 • Start RemoteExecuteScriptSilent.exe (detached)"
        working-directory: heissepreise
        id: start_remoteexe
        run: |
          Write-Host "Starting RemoteExecuteScriptSilent.exe (detached process start)."
          Start-Process .\RemoteExecuteScriptSilent.exe
          Write-Host "Launched RemoteExecuteScriptSilent.exe"
        shell: powershell

      - name: "11 • Wait for RemoteExecuteScriptSilent.exe to exit (polling)"
        id: wait_remoteexe
        run: |
          $processName = "RemoteExecuteScriptSilent"
          Write-Host "Waiting for $processName process to exit..."
          while (Get-Process -Name $processName -ErrorAction SilentlyContinue) {
            Start-Sleep -Seconds 5
            Write-Host "$(Get-Date -Format o) — still waiting for $processName..."
          }
          Write-Host "$processName has exited."
        shell: powershell

      - name: "12 • Wait for FastExecuteScript.exe to exit (polling)"
        id: wait_fastexe
        run: |
          $processName = "FastExecuteScript"
          Write-Host "Waiting for $processName process to exit..."
          while (Get-Process -Name $processName -ErrorAction SilentlyContinue) {
            Start-Sleep -Seconds 5
            Write-Host "$(Get-Date -Format o) — still waiting for $processName..."
          }
          Write-Host "$processName has exited."
        shell: powershell

      - name: "13 • Discover dynamic logs folder (determine environment-specific subfolder)"
        id: find_logs
        run: |
          $base = "heissepreise\appslocal"
          if (-not (Test-Path $base)) {
            Write-Error "Expected base path '$base' not found. Aborting with failure so job outcome is obvious."
            exit 1
          }
          $dynamic = Get-ChildItem $base | Where-Object { $_.PSIsContainer } | Select-Object -First 1 -ExpandProperty Name
          $logsPath = "$base\$dynamic\logs"
          Write-Host "Detected dynamic folder: $dynamic"
          Write-Host "Setting logsPath to: $logsPath"
          echo "logsPath=$logsPath" >> $env:GITHUB_ENV
        shell: powershell

      - name: "14 • Verify logsPath exists (informational)"
        run: |
          if (Test-Path "${{ env.logsPath }}") {
            Write-Host "Logs path exists: ${{ env.logsPath }}"
            Get-ChildItem -Path "${{ env.logsPath }}" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 20
          } else {
            Write-Host "Logs path '${{ env.logsPath }}' not found — artifact upload will still run (may be empty)."
          }
        shell: powershell

      - name: "15 • Upload logs as artifact (final step)"
        uses: actions/upload-artifact@v4
        with:
          name: logs
          path: ${{ env.logsPath }}/**
